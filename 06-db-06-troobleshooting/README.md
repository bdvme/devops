*Студент: Дмитрий Багрянский*

# Домашняя работа

## Урок 6.6. Troubleshooting

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её
нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

###### Ответ:

* напишите список операций, которые вы будете производить для остановки запроса пользователя

1. Посмотрю активные запросы текущего пользователя длящиеся более 180 секунд

```js
db.currentOp(
  {
    "active": true,
    "$ownOps": true
    "secs_running": {
      "$gt" : 180
    }
  }
)
```

2. Затем в ответе находим идентификатор операции opid и передаём это значение в db.killOp()

```js
db.killOp(opid)
```

* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

1. Использовать метод [`maxTimeMS()`](https://docs.mongodb.com/manual/tutorial/terminate-running-operations/#maxtimems)

Например ограничить время выполнения запроса не более 2 минут

```js
db.collection.find().maxTimeMS(120000)
```

2. Включить [профайлер](https://docs.mongodb.com/manual/tutorial/manage-the-database-profiler/) чтобы отловить медленные запросы, изучить их с помощью [explain](https://docs.mongodb.com/manual/reference/explain-results/#executionstats) и попробовать оптимизировать: денормализовать данные, добавить/удалить индексы, настроить шардинг и т.д.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL.
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

###### Ответ:

* Предположим что в базе данных много ключей, время жизни которых истекает одновременно, Redis может заблокировать запись новых ключей, чтоб снизить процент ключей время жизни которых уже истекло. Redis блокирует запись новых ключей для того чтобы избежать использования слишком большого использования памяти для ключей, время жизни которых уже истекло.

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

###### Ответ:

* Возможно эта проблема возникла из-за роста количества записей, когда большое количество строк отправляются как один или несколько запросов. Нужно попробовать увеличить параметр `net_read_timeout` до 60 секунд и более, чтобы хватало времени для завершения передачи данных. Так же стоит проверить состояние индексов, актуальность данных, проанализировать хватает ли БД ресурсов, проверить состояние сети.

## Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

###### Ответ:

* Пример недостатка оперативной памяти. Можно либо завершить отдельные процессы для освобождения памяти, либо радикально обрушить всю систему.

* Необходимо:
  * увеличить объем памяти на сервере;
  * настроить перевыделение памяти в `sysctl.conf`

    `vm.overcommit_memory = 2` - отказ обработки запросов, запрашивающих память, размер которой превышает суммарный размер памяти пространства подкачки и ОЗУ в соответствии с `overcommit_ratio`.

    `vm.overcommit_ratio = 60` - если `overcommit_memory` равен 2, определяет процентную часть физической памяти. По умолчанию равен 50.
  * настроить `swap`
  * оптимизировать запросы, проверить состояние индексов.
